/**
 * @fileoverview Description of this file.
 */

window.WombatAccessibilityHelpers = {
  /**
   * Programmatically set focus for A11y purposes to select focus for screen
   * readers. Multiple focus calls necessary to ensure screen reader usability.
   * Source
   * https://silvantroxler.ch/2016/setting-voiceover-focus-with-javascript/
   * @param {!Element} element
   */
  setVoiceOverFocus: element => {
    const focusInterval = 30;          // ms, time between function calls
    const focusTotalRepetitions = 30;  // number of repetitions

    element.setAttribute('tabindex', '0');
    element.blur();

    let focusRepetitions = 0;
    const interval = setInterval(function() {
      element.focus();
      focusRepetitions++;
      if (focusRepetitions >= focusTotalRepetitions) {
        clearInterval(interval);
      }
    }, focusInterval);
  }
};
/**
 * @fileoverview JavaScript type prototype overrides and expansions.
 */

/**
 * "foo %@2 %@1".fmt('qux', 'bar') => "foo bar qux"
 *
 * @function fmt adds the format function to the String prototype.
 * @return {string} formatted string
 */
String.prototype.fmt = function() {
  var str = this;
  for(var i = 1; i <= arguments.length; i++) {
    str = str.replace(new RegExp("%@" + i, "g"), arguments[i-1]);
  }
  return str;
};
/**
 * @fileoverview Description of this file.
 */

window.wombatDefaults = {
  galleryTransitionSpeed: 350,
  galleryAutoAdvanceSpeed: 2500,
};
/**
 * @fileoverview This is bundle.min.js from gstore-element-watcher repo
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WombatElementWatcher=f()}})(function(){var define,module,exports;return(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;if("value" in descriptor)descriptor.writable=!0;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}
var _require=require('../utilities'),logElement=_require.logElement;module.exports=function(){function Element(_ref,disposalHandler,scrollY){var domNode=_ref.domNode,_ref$callback=_ref.callback,callback=_ref$callback===undefined?function(){return domNode.classList.add('is-visible')}:_ref$callback,_ref$enter=_ref.enter,enter=_ref$enter===undefined?callback:_ref$enter,exit=_ref.exit,persist=_ref.persist,_ref$once=_ref.once,once=_ref$once===undefined?!persist:_ref$once,_ref$enterOnce=_ref.enterOnce,enterOnce=_ref$enterOnce===undefined?once:_ref$enterOnce,_ref$exitOnce=_ref.exitOnce,exitOnce=_ref$exitOnce===undefined?once:_ref$exitOnce,_ref$offset=_ref.offset,offset=_ref$offset===undefined?function(){return Math.min(window.innerHeight,domNode.offsetHeight)*0.50}:_ref$offset,_ref$enterOffset=_ref.enterOffset,enterOffset=_ref$enterOffset===undefined?offset:_ref$enterOffset,_ref$exitOffset=_ref.exitOffset,exitOffset=_ref$exitOffset===undefined?window.innerHeight+domNode.offsetHeight:_ref$exitOffset,debug=_ref.debug;_classCallCheck(this,Element);this.domNode=domNode;this.disposalHandler=disposalHandler;this.enterHandler=enter;this.enterOffset=enterOffset;this.enterTriggerY=null;this.hasFiredEnter=!1;this.enterOnce=enterOnce;this.exitHandler=exit;this.exitOffset=exitOffset;this.exitTriggerY=null;this.hasFiredExit=!1;this.exitOnce=exitOnce;this.isActive=!1;this.isReversed=!1;this.domNodeTopPageOffset=null;this.scrollY=scrollY;this.isDebugging=debug;this.update()}
_createClass(Element,[{key:'update',value:function update(){this.setDomNodeTopPageOffset();this.setTriggers();this.handleDebug()}},{key:'setDomNodeTopPageOffset',value:function setDomNodeTopPageOffset(){var element=this.domNode;var domNodeTopPageOffset=0;while(element.offsetParent){domNodeTopPageOffset+=element.offsetTop-element.scrollTop+element.clientTop;element=element.offsetParent}
this.domNodeTopPageOffset=domNodeTopPageOffset}},{key:'setTriggers',value:function setTriggers(){var _this=this;['enter','exit'].forEach(function(type){var baseDomNodeOffset=_this.isReversed?_this.domNodeTopPageOffset+_this.domNode.offsetHeight+window.innerHeight:_this.domNodeTopPageOffset;var offset=_this[type+'Offset'].constructor===Function?_this[type+'Offset'](_this.domNode):_this[type+'Offset'];_this[type+'TriggerY']=_this.isReversed?baseDomNodeOffset-offset:baseDomNodeOffset+offset})}},{key:'handleState',value:function handleState(scrollY){this.scrollY=scrollY;var hasHandlers=this.enterHandler||this.exitHandler;var hasNeverEntered=!(this.hasFiredEnter&&this.enterOnce);var hasNeverExited=!(this.hasFiredExit&&this.exitOnce);var isScrolledPastEnterTrigger=this.isReversed?this.enterTriggerY>=this.scrollY:this.enterTriggerY<=this.scrollY;var isScrolledPastExitTrigger=this.isReversed?this.exitTriggerY>=this.scrollY:this.exitTriggerY<=this.scrollY;var hasBackedOut=!isScrolledPastEnterTrigger&&this.enterTriggerY!==this.scrollY;var shouldCallEnterHandler=hasNeverEntered&&isScrolledPastEnterTrigger&&!isScrolledPastExitTrigger&&!this.isActive;var shouldCallExitHandler=hasNeverExited&&(isScrolledPastExitTrigger||hasBackedOut)&&this.hasFiredEnter&&this.isActive;var isDisposable=!hasHandlers||!hasNeverEntered&&!(hasNeverExited&&this.exitHandler);if(shouldCallEnterHandler)this.handleEnter();if(shouldCallExitHandler)this.handleExit(hasBackedOut);if(isDisposable)this.disposalHandler()}},{key:'handleEnter',value:function handleEnter(){logElement(Object.assign({mode:'ENTER'},this));this.isActive=!0;this.hasFiredEnter=!0;if(this.enterHandler)this.enterHandler(this.domNode);this.updateTriggerReferenceElementContent('enter');this.domNode.dispatchEvent(new Event('enter'))}},{key:'handleExit',value:function handleExit(hasBackedOut){logElement(Object.assign({mode:'EXIT',hasBackedOut:hasBackedOut},this));this.isActive=!1;this.hasFiredExit=!0;if(this.exitHandler)this.exitHandler(this.domNode);this.updateTriggerReferenceElementContent('exit');this.domNode.dispatchEvent(new Event('exit'));if(!hasBackedOut)this.reverseEnterExit()}},{key:'updateTriggerReferenceElementContent',value:function updateTriggerReferenceElementContent(type){if(this.isDebugging){if(!/FIRED: \d*$/.test(this[type+'NameElement'].textContent)){this[type+'NameElement'].textContent+=' FIRED: 0'}
this[type+'NameElement'].textContent=this[type+'NameElement'].textContent.replace(/\d*$/,function(match){return+match+1});if(this[type+'Once'])this[type+'NameElement'].textContent+=' INACTIVE'}}},{key:'handleDebug',value:function handleDebug(){var _this2=this;if(!this.isDebugging)return;if(!this.enterTriggerReferenceElement){var name=this.domNode.id||this.domNode.classList.toString();['enter','exit'].forEach(function(type){var handler=_this2[type+'Handler'];_this2[type+'TriggerReferenceElement']=document.createElement('trigger');_this2[type+'NameElement']=document.createElement('span');_this2[type+'NameElement'].textContent=name+' '+type.toUpperCase()+(handler?'':' -NO HANDLER-');_this2[type+'NameElement'].style.cssText='background-color: white';_this2[type+'TriggerReferenceElement'].appendChild(_this2[type+'NameElement']);document.body.appendChild(_this2[type+'TriggerReferenceElement'])})}
var triggerColors={enter:this.isReversed?'royalblue':'green',exit:this.isReversed?'orange':'red'};['enter','exit'].forEach(function(type){var triggerY=_this2.isReversed?_this2[type+'TriggerY']:_this2[type+'TriggerY']-window.innerHeight;_this2[type+'TriggerReferenceElement'].style.cssText='position: absolute; display: block; z-index: 9999; height: 2px; left: 0; right: 0; top: '+triggerY+'px; background-color: '+triggerColors[type]+';'})}},{key:'reverseEnterExit',value:function reverseEnterExit(){this.isReversed=!this.isReversed;this.setTriggers();this.handleDebug()}}]);return Element}()},{"../utilities":4}],2:[function(require,module,exports){'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;if("value" in descriptor)descriptor.writable=!0;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i]}return arr2}else{return Array.from(arr)}}
function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}
var Element=require('./Element');var _require=require('../utilities'),throttle=_require.throttle,getDomNodes=_require.getDomNodes,params=_require.params;module.exports=function(){function Watcher(){var _this=this;_classCallCheck(this,Watcher);this.elements={};this.throttleScroll=throttle();this.throttleResize=throttle();this.windowInnerWidth=window.innerWidth;this.windowInnerHeight=window.innerHeight;this.scrollHeight=document.documentElement.scrollHeight;addEventListener('scroll',function(){return _this.handleScroll()});addEventListener('resize',function(){return _this.handleResize()});this.handleScrollHeightChange()}
_createClass(Watcher,[{key:'setScrollPosition',value:function setScrollPosition(){this.scrollY=window.pageYOffset+window.innerHeight}},{key:'handleScrollHeightChange',value:function handleScrollHeightChange(){var _this2=this;setInterval(function(){if(_this2.scrollHeight!==document.documentElement.scrollHeight){_this2.scrollHeight=document.documentElement.scrollHeight;_this2.setScrollPosition();Object.keys(_this2.elements).forEach(function(id){var element=_this2.elements[id];element.setDomNodeTopPageOffset();element.setTriggers();element.handleDebug()})}},500)}},{key:'handleScroll',value:function handleScroll(){var _this3=this;this.setScrollPosition();Object.keys(this.elements).forEach(function(id){return _this3.elements[id].handleState(_this3.scrollY)})}},{key:'handleResize',value:function handleResize(){var _this4=this;this.throttleResize(function(){var _window=window,innerWidth=_window.innerWidth,innerHeight=_window.innerHeight;_this4.setScrollPosition();if(innerWidth!==_this4.windowInnerWidth){_this4.windowInnerWidth=innerWidth;_this4.windowInnerHeight=innerHeight;return Object.keys(_this4.elements).forEach(function(id){return _this4.elements[id].update()})}
if(innerHeight!==_this4.windowInnerHeight){_this4.windowInnerHeight=innerHeight;Object.keys(_this4.elements).forEach(function(id){var element=_this4.elements[id];element.setDomNodeTopPageOffset();element.setTriggers();element.handleDebug()})}},function(){return _this4.handleResize()},100)}},{key:'add',value:function add(elementOptions){var _this5=this;var el=elementOptions.el,element=elementOptions.element,_elementOptions$eleme=elementOptions.elements,elements=_elementOptions$eleme===undefined?document.querySelectorAll('section'):_elementOptions$eleme,_elementOptions$debug=elementOptions.debug,debug=_elementOptions$debug===undefined?params.debug:_elementOptions$debug;var addElements=function addElements(){var domNodes=getDomNodes(el||element||elements);_this5.setScrollPosition();return domNodes.reduce(function(domNodes,domNode){if(!domNode)return domNodes;var id=Math.random()*Date.now();var disposalFn=function disposalFn(){return delete _this5.elements[id]};var watchedElement=new Element(Object.assign({domNode:domNode,debug:debug},elementOptions),disposalFn,_this5.scrollY);_this5.elements[id]=watchedElement;if(_this5.scrollY>watchedElement.enterTriggerY)watchedElement.reverseEnterExit();watchedElement.handleState(_this5.scrollY);return[].concat(_toConsumableArray(domNodes),[watchedElement])},[])};return new Promise(function(resolve){if(document.readyState==='complete')return resolve(addElements());document.addEventListener('readystatechange',function(){return resolve(addElements())})})}}]);return Watcher}()},{"../utilities":4,"./Element":1}],3:[function(require,module,exports){'use strict';var Watcher=require('./constructors/Watcher');var elementWatcher=new Watcher();module.exports=elementWatcher},{"./constructors/Watcher":2}],4:[function(require,module,exports){'use strict';var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=!0;var _d=!1;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=!0){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=!0;_e=err}finally{try{if(!_n&&_i["return"])_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError("Invalid attempt to destructure non-iterable instance")}}}();function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0})}else{obj[key]=value}return obj}
function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i]}return arr2}else{return Array.from(arr)}}
function getDomNodes(maybeNode){if(maybeNode instanceof NodeList||Array.isArray(maybeNode)){return[].concat(_toConsumableArray(maybeNode)).reduce(function(nodes,node){return[].concat(_toConsumableArray(nodes),_toConsumableArray(getDomNodes(node)))},[])}
if(maybeNode instanceof String){var domNode=document.querySelector(maybeNode);return[domNode]}
if(typeof jQuery==='function'&&maybeNode instanceof jQuery){return[maybeNode.get(0)]}
if(maybeNode instanceof HTMLElement){return[maybeNode]}}
function throttle(){var timer=void 0;var value=void 0;return function(throttledFn,callback,delay){if(!timer){setTimeout(function(){value=throttledFn();callback()},0);timer=setTimeout(function(){timer=undefined},delay||10)}
return value}}
function logElement(_ref){var mode=_ref.mode,domNode=_ref.domNode,_ref$domNode=_ref.domNode,id=_ref$domNode.id,className=_ref$domNode.className,enterTriggerY=_ref.enterTriggerY,enterHandler=_ref.enterHandler,exitTriggerY=_ref.exitTriggerY,exitHandler=_ref.exitHandler,_ref$trigger=_ref.trigger,trigger=_ref$trigger===undefined?enterTriggerY||exitTriggerY:_ref$trigger,scrollY=_ref.scrollY,hasBackedOut=_ref.hasBackedOut,isReversed=_ref.isReversed,isActive=_ref.isActive,isDebugging=_ref.isDebugging;if(isDebugging){console.info({domNode:domNode,mode:mode,id:id,className:className,trigger:trigger,scrollY:scrollY,isReversed:isReversed,hasBackedOut:hasBackedOut,isActive:isActive,enterHandler:enterHandler,exitHandler:exitHandler})}}
var getQueryParams=window.location.search.slice(1).split('&').reduce(function(queryParams,queryParam){if(!queryParam)return queryParams;var _queryParam$split=queryParam.split('='),_queryParam$split2=_slicedToArray(_queryParam$split,2),key=_queryParam$split2[0],value=_queryParam$split2[1];return Object.assign(queryParams,_defineProperty({},key,value))},{});module.exports={getDomNodes:getDomNodes,throttle:throttle,logElement:logElement,params:getQueryParams}},{}]},{},[3])(3)})
/**
 * @fileoverview Description of this file.
 */

/**
 * @function WombatTouchWatcher Class that triggers events for user swipe movements
 * @param {!HTMLElement} scopeElement the element that the touch watcher is attached to
 */
function WombatTouchWatcher(scopeElement) {
  var touchStartPosition = [];
  var touchEndPosition = [];
  var touchMovePositions = [];

  var dispatchEvents = {
    swipeLeft: new Event('swipe-left'),
    swipeRight: new Event('swipe-right'),
    swipeUp: new Event('swipe-up'),
    swipeDown: new Event('swipe-down'),
  };

  function analyzeTouch() {
    var leftRight = touchEndPosition[0] - touchStartPosition[0];
    var upDown = touchEndPosition[1] - touchStartPosition[1];

    if (Math.abs(upDown) > Math.abs(leftRight)) {
      if (upDown > 10) {
        scopeElement.dispatchEvent(dispatchEvents.swipeDown);
      } else if (upDown < 10) {
        scopeElement.dispatchEvent(dispatchEvents.swipeUp);
      } else {
        // no movement.
        // console.log('no movement');
      }
    } else {
      if (leftRight > 10) {
        scopeElement.dispatchEvent(dispatchEvents.swipeRight);
      } else if (leftRight < 10) {
        scopeElement.dispatchEvent(dispatchEvents.swipeLeft);
      } else {
        // no movement.
        // console.log('no movement');
      }
    }
  }

  function touchStart(evt) {
    var touches = evt.changedTouches[0];
    touchStartPosition = [touches.pageX, touches.pageY];
    touchEndPosition = [];
    touchMovePositions = [];
    // console.log('function touchStart', touchStartPosition);
  }

  function touchMove(evt) {
    var touches = evt.changedTouches[0];
    // console.log(evt.changedTouches.length);
    touchMovePositions.push([touches.pageX, touches.pageY]);
    // console.log('function touchMove', touchMovePositions);
  }

  function touchEnd(evt) {
    var touches = evt.changedTouches[0];
    touchEndPosition = [touches.pageX, touches.pageY];
    // console.log('function touchEnd', touchEndPosition);
    analyzeTouch();
  }

  function setupEventListeners() {
    scopeElement.addEventListener('touchstart', touchStart);
    scopeElement.addEventListener('touchmove', touchMove);
    scopeElement.addEventListener('touchend', touchEnd);
  }

  function init() {
    setupEventListeners();
  }

  init();

  this.destroy = function() {
    scopeElement.removeEventListener('touchstart', touchStart);
    scopeElement.removeEventListener('touchmove', touchMove);
    scopeElement.removeEventListener('touchend', touchEnd);
  };
}
/**
 * @fileoverview WombatElementWatcherDefaults Class that triggers when user enters / exits on the scoped element.
 */

/**
 * @function WombatElementWatcherDefaults is the class for the default setup wombat
 * templates will use for the elementWatcher
 * @param {!HTMLElement} scopeElement the element that the element watcher is attached to
 */
function WombatElementWatcherDefaults(scopeElement) {

  this.init = function() {
    WombatElementWatcher.add({
      element: scopeElement,
      enter(scopeElement) {
        scopeElement.classList.add('in-view');

        var inView = document.createEvent('Event');
        inView.initEvent('in-view', true, true);

        scopeElement.dispatchEvent(inView);
      },
      exitOffset(scopeElement) {
        var exitPosition = window.innerHeight + scopeElement.offsetHeight;
        return exitPosition;
      },
      exit(scopeElement) {
        scopeElement.classList.remove('in-view');

        var outOfView = document.createEvent('Event');
        outOfView.initEvent('out-of-view', true, true);

        scopeElement.dispatchEvent(outOfView);
      },
      persist: true,
    });
  };

  this.init();
}
/**
 * @fileoverview Service for lazy loading image src attributes
 * HTML Usage
 *
 * Examples for lazy loading background-image:
 *
 * <section wombat-template lazy-load
 *   data-desktop-src="..."
 *   data-tablet-src="..."
 *   data-mobile-src="..."></section>
 *
 * <div role="img" lazy-load
 *   data-desktop-src="..."
 *   data-tablet-src="..."
 *   data-mobile-src="..."></div>
 *
 *
 * Example for lazy loading img tag source:
 *
 * <img lazy-load
 *   data-mobile-src="..."
 *   data-tablet-src="..."
 *   data-desktop-src="..."/>
 *

 * Example for lazy loading video source:
 *
 * <video lazy-load autoplay playsinline muted disableremoteplayback>
 *   <source data-mobile-src="..."
 *       data-tablet-src="..."
 *       data-desktop-src="..." type="video/mp4"></source>
 * </video>
 *
 * NOTE: If mobile and/or tablet sources are not present the source defaults to
 *       desktop.
 */

/**
 * Changes src attribute on img tag when it comes into viewport.
 * @param {!HTMLElement} scopeElement Image element
 */
function WombatLazyLoad(scopeElement) {
  // TODO Redefine based on data
  const mobileMQ = window.matchMedia('(max-width: 599px)');
  const tabletMQ =
      window.matchMedia('(min-width: 600px) and (max-width: 767px)');
  let resizeTimer;
  let observer;
  const params = new URLSearchParams(window.location.search);
  const hasDisableParam = params.get('disableLazyLoad');

  /**
   * Sets class when image/video resource has been loaded.
   */
  const setImageLoadedClass = () =>
      scopeElement.classList.add('lazy-image-loaded');

  /**
   * Callback function from IntersectionObserver which updates asset sources if
   * element is visible to user.
   * @param {!IntersectionObserverEntry} entries Entries of elements observed
   */
  const observerCallback = entries => {
    entries.forEach(entry => {
      const {target, intersectionRatio} = entry;
      const isVisible = intersectionRatio > 0;

      if (isVisible) {
        setSource(target);
        window.addEventListener('resize', resizeEventHandler);
      } else {
        window.removeEventListener('resize', resizeEventHandler);
      }
    });
  };

  /**
   * Fetches source url that matches current viewport
   * @param {!HTMLElement} element element to get viewport sources from
   * @return {string} Source of asset based on viewport
   */
  const getResponsiveSource = element => {
    const {mobileSrc, tabletSrc, desktopSrc} = element.dataset;

    if (mobileMQ.matches && mobileSrc) {
      return mobileSrc;
    } else if (tabletMQ.matches && tabletSrc) {
      return tabletSrc;
    } else {
      return desktopSrc;
    }
  };

  /**
   * Sets the source url for the video, img or background of the current element
   * @param {!HTMLElement} element element to set source on
   */
  const setSource = element => {
    const source = getResponsiveSource(element);

    switch (element.tagName) {
      case 'IMG':
        if (element.src !== source) {
          element.src = source;
        }
        break;
      case 'VIDEO':
        const sourceElements = [...element.children];
        sourceElements.forEach(sourceElement => {
          const videoSource = getResponsiveSource(sourceElement);
          if (sourceElement.src !== videoSource) {
            sourceElement.src = videoSource;
            element.load();
          }
        });
        break;
      default:
        const backgroundValue = `url(${source})`;
        const currentBackgroundValue =
            element.style.getPropertyValue('--lazy-load-source');

        if (currentBackgroundValue !== backgroundValue) {
          element.style.setProperty('--lazy-load-source', backgroundValue);
        }
        break;
    }
  };

  /**
   * Event handler that updates the source if the viewport has changed
   */
  const resizeEventHandler = () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      setSource(scopeElement);
    }, 250);
  };


  const disableLazyLoadListener = () => {
    const target = document.documentElement;
    const observer = new MutationObserver((mutations) => {
      for (let mutation of mutations) {
        const classAdded = mutation.type === 'attributes' &&
            mutation.attributeName === 'class' &&
            target.classList.contains('disable-lazy-load');
        if (classAdded) {
          setSource(scopeElement);
          window.addEventListener('resize', resizeEventHandler);
          observer.disconnect();
        }
      }
    });

    observer.observe(
        target, {attributes: true, childList: false, subtree: false});
  };

  this.init = () => {
    const isDisabled = hasDisableParam;
    disableLazyLoadListener();

    scopeElement.addEventListener('load', setImageLoadedClass);
    scopeElement.addEventListener('loadeddata', setImageLoadedClass);

    if (isDisabled) {
      setSource(scopeElement);
      window.addEventListener('resize', resizeEventHandler);
    } else {
      observer = new IntersectionObserver(observerCallback, {threshold: 0});
      observer.observe(scopeElement);
    }
  };

  this.destroy = () => {
    if (observer) observer.unobserve(scopeElement);
    window.removeEventListener('resize', resizeEventHandler);
    scopeElement.removeEventListener('load', setImageLoadedClass);
    scopeElement.removeEventListener('loadeddata', setImageLoadedClass);
  };

  this.init();
}
/**
 * @function WombatFormatAnchors Format markdown style links into anchor tags
 * @param {!HTMLelement} scopeElement Element to format links
 */
var WombatFormatAnchors = function(scopeElement) {
  var anchorMatch = new RegExp(
      /\[([^\[\]]+?)\]\(((?:https?:)?(?:\/\/)?[a-z0-9-._~:\/?#\[\]@!$&'()*+,;=]+)\)/ig);

  function markdownToLinks() {
    scopeElement.innerHTML = scopeElement.innerHTML.replace(
        anchorMatch, '<a href="$2" title="$1">$1</a>');
  }

  this.init = function() {
    markdownToLinks();
  };

  this.init();
};
/**
 * @fileoverview Handles sending events to GTM
 */

/**
 * @function WombatAnalyticsClickHandler
 * @param {!HTMLElement} scopeElement
 */
function WombatAnalytics(scopeElement) {
  const moduleType = scopeElement.getAttribute('data-module-type');
  const sectionName = scopeElement.getAttribute('data-section-name');
  const hasElementWatcher = scopeElement.hasAttribute('element-watcher');
  let time;
  const _this = this;

  const getDocidFromUrl = (url) => {
    return url?.match(/(product|config)\/([^/?]+)/)?.[2];
  };

  const productDocid = getDocidFromUrl(window.location.pathname);
  const getMannequinService = new Promise(resolve => {
    const interval = () => window.mannequinService ?
        resolve(window.mannequinService) :
        window.requestAnimationFrame(interval);
    window.requestAnimationFrame(interval);
  });

  const getProductData = async function(docid) {
    if (!docid) return;
    const service = await getMannequinService;
    const data = await service.fetchProductCtaData([docid]);
    return data.get(docid);
  };

  /**
   * Handles tracking of events
   * @param {string} label Event label
   * @param {string} interactionType Event to be tracked
   * @param {!HTMLEvent} e Event to be tracked
   * @return {void}
   */
  this.track = async function(label, interactionType, e) {
    if (e == null || e.target == null) {
      return;
    }

    const pageName = window.location.pathname;
    const service = await getMannequinService;
    const _interactionType = interactionType || 'click';
    const _nonInteraction =
        Number(!['click', 'swipe', 'drag'].includes(_interactionType))
            .toString();

    const docid = getDocidFromUrl(e.target.getAttribute('href'));
    const productData = await getProductData(docid);
    service.logEvent({
      event: 'module interaction',
      nonInteraction: String(_nonInteraction),
      eventAction: sectionName,
      eventCategory: 'module ' + _interactionType,
      eventLabel: label,
      eventParams: {
        moduleName: sectionName,
        moduleType: moduleType,
        pageName: pageName,
        linkText: e.target.textContent || 'not set',
        destinationUrl: productData ? productData.url : label,
        productDetailsPageDocId: productData?.pageId,
        productFamilyDocId: productData?.productFamilyDocid,
        productDocId: docid ? docid : null
      }
    });
  };

  function _trackClick(event) {
    const label = event.target.getAttribute('data-track-label');
    _this.track(label || '(not set)', 'click', event);
  }

  this.setClickTracking = scopeElement => {
    scopeElement.querySelectorAll('[track-click]').forEach(function(element) {
      element.addEventListener('click', _trackClick);
    });
  };

  this.unsetClickTracking = scopeElement => {
    scopeElement.querySelectorAll('[track-click]').forEach(function(element) {
      element.removeEventListener('click', _trackClick);
    });
  };

  async function _trackInView() {
    time = Date.now();
    const service = await getMannequinService;
    service.logEvent({
      event: 'module inview',
      nonInteraction: '1',
      eventAction: sectionName,
      eventCategory: 'module inview',
      eventLabel: '(not set)',
      eventParams: {
        moduleName: sectionName,
        moduleType: moduleType,
        pageName: window.location.pathname,
        productDetailsPageDocId: productDocid,
        productDocId: productDocid
      }
    });
  }

  async function _trackOutOfView() {
    const service = await getMannequinService;
    service.logEvent({
      event: 'module outview',
      nonInteraction: '1',
      eventAction: sectionName,
      eventCategory: 'module outview',
      eventLabel: '(not set)',
      eventParams: {
        moduleName: sectionName,
        moduleType: moduleType,
        pageName: window.location.pathname,
        secondsInView: Number((Date.now() - time) / 1000),
        productDetailsPageDocId: productDocid,
        productDocId: productDocid
      }
    });
  }

  function setInViewTracking() {
    scopeElement.addEventListener('in-view', _trackInView, {once: true});
    scopeElement.addEventListener('out-of-view', _trackOutOfView, {once: true});
  }

  function unsetInViewTracking() {
    scopeElement.removeEventListener('in-view', _trackInView);
    scopeElement.removeEventListener('out-of-view', _trackOutOfView);
  }

  this.init = function() {
    this.setClickTracking(scopeElement);
    if (hasElementWatcher) setInViewTracking();
  };

  this.destroy = function() {
    this.unsetClickTracking(scopeElement);
    if (hasElementWatcher) unsetInViewTracking();
  };

  this.init();
}
/**
 * Converts elements with data-telephone attributes to anchors with `tel:` uris
 * @param {!HTMLElement} scopeElement Active element passed from wombat router
 */
var WombatPhoneLinks = function(scopeElement) {
  const init = () => {
    const link = document.createElement('a');
    const phoneNumber = scopeElement.innerHTML;
    link.classList.add('id-no-nav');
    link.href = `tel:${phoneNumber}`;
    link.innerHTML = scopeElement.innerHTML;
    scopeElement.parentNode.replaceChild(link, scopeElement);
  };

  init();
};
/**
 * @function WombatAsyncCtaHandler
 * @param {!HTMLElement} scopeElement
 */

function WombatAsyncCtaHandler(scopeElement) {
  const Behavior = {
    UNSPECIFIED: '0',
    REDIRECT: '1',
    JOIN_WAITLIST: '2',
    SIGN_IN_AND_JOIN_WAITLIST: '3',
    LEAVE_WAITLIST: '4',
    ADD_TO_CART: '5',
    DISABLED: '6',
  };
  let observer;

  const loginUrl =
      'https://accounts.google.com/ServiceLogin?ltmpl=googlestore&continue=';

  const observeCTAState = () => {
    observer = new MutationObserver(([mutation], observer) => {
      if (mutation.type === 'attributes') {
        compareAndUpdateCTA();
        observer.disconnect();
      }
    });

    observer.observe(
        scopeElement,
        {attributes: true, attributeFilter: ['data-cta-behavior']});
  };

  /**
   * Update button Url & text if PDB CTA is different than current button
   */
  const compareAndUpdateCTA = () => {
    const pdbBarButton = document.getElementById('pdp-bar-cta-button');

    // Update current buttons text if it does not match PDB CTA text
    if (pdbBarButton && shouldUpdateText(pdbBarButton)) {
      scopeElement.textContent = pdbBarButton.textContent;
    }

    // Update current buttons Url if it does not match PDB CTA Url
    if (pdbBarButton && shouldUpdateUrl(pdbBarButton)) {
      scopeElement.dataset.ctaBehavior = Behavior.REDIRECT;
      scopeElement.dataset.ctaUrl = pdbBarButton.dataset.ctaTargetUrl;
    }
  };

  const shouldUpdateText = pdbBarButton =>
      pdbBarButton.textContent !== scopeElement.textContent;

  const shouldUpdateUrl = pdbBarButton => pdbBarButton.dataset.ctaTargetUrl &&
      (pdbBarButton.dataset.ctaTargetUrl !== scopeElement.dataset.ctaUrl);


  const handleAsyncCtaClick = () => {
    const docid = scopeElement.dataset.docid;
    switch (scopeElement.dataset.ctaBehavior) {
      case Behavior.REDIRECT:
        if (scopeElement.dataset.ctaUrl) {
          mannequinService.navigateToUrl(scopeElement.dataset.ctaUrl);
        }
        break;
      case Behavior.JOIN_WAITLIST:
        scopeElement.disabled = true;
        mannequinService.joinWaitlist(docid).then(() => {
          scopeElement.disabled = false;
        });
        break;
      case Behavior.SIGN_IN_AND_JOIN_WAITLIST:
        const encodedHref = encodeURIComponent(location.href);
        mannequinService.navigateToUrl(`${loginUrl}${encodedHref}`);
        break;
      case Behavior.LEAVE_WAITLIST:
        scopeElement.disabled = true;
        mannequinService.leaveWaitlist(docid).then(() => {
          scopeElement.disabled = false;
        });
        break;
      case Behavior.ADD_TO_CART:
        scopeElement.disabled = true;
        mannequinService.addToCart(docid).then(({redirectUrl}) => {
          mannequinService.navigateToUrl(redirectUrl);
        });
        break;
      case Behavior.UNSPECIFIED:
      case Behavior.DISABLED:
      default:
        // do nothing
    }
  };

  this.init = function() {
    observeCTAState();

    // Attach a click handler to the async CTA button.
    scopeElement.addEventListener('click', handleAsyncCtaClick);
  };

  this.destroy = function() {
    observer.disconnect();
    scopeElement.removeEventListener('click', handleAsyncCtaClick);
  };

  this.init();
}
/**
 * Redux that manages state of accessories wall data
 * @param {!Function} reducer runs when state changes
 * @param {!Object=} initialState for store
 * @return {!Object} Object of functions that manage state
 */
window.wombatReduxStore = function(reducer, initialState = {}) {
  let listeners = new Set();
  let state = reducer(initialState, {});

  return {
    getState: () => state,
    dispatch: (action, value) => {
      state = reducer(state, action, value);
      listeners.forEach(listener => listener(state));
    },
    subscribe: (newListener) => {
      listeners.add(newListener);

      const unsubscribe = () => listeners.delete(newListener);

      return unsubscribe;
    },
  };
};
/**
 * @fileoverview Utilities for images mainly pertaining to fife param management
 */
window.WombatImageUtils = new (function() {
  const PARAM_REGEXP = /=(.*)$/i;

  this.getFifeParams = url => {
    const match = url.match(PARAM_REGEXP);
    return match ? match[1].split('-') : [];
  };

  this.setWidthByElement = (url, element) => {
    const width = element.clientWidth * window.devicePixelRatio;
    return this.setWidth(url, width);
  };

  this.setWidth = (url, width) => {
    const params = this.getFifeParams(url).filter(p => !p.startsWith('w'));
    const hasParams = params.length > 0;
    // Rounding to prevent decimal value i.e. 500.5 vs 501
    params.push(`w${Math.round(width)}`);
    const paramsStr = `=${params.join('-')}`;
    return hasParams ? url.replace(PARAM_REGEXP, paramsStr) : url + paramsStr;
  };
});
/**
 * @fileoverview Handles focusing, focus trapping, and a11y functionality for
 * modals
 *
 * HTML Setup for modal:
 * ```
 * <div class="gs-modal" id="modal-test" tabindex="-1" role="dialog">
 *   <a href="#" role="button" class="overlay close-modal id-no-nav"></a>
 *   <div class="gs-modal-content" style="--width: {$max_width};
 * --height: {$max_height};"> <div class="gs-modal-header"> // header required
 *       <h1>Modal Header</h1> // heading optional
 *       <a href="#" role="button" class="close-modal id-no-nav close-x">╳</a>
 *     </div>
 *     # !! Use .gs-modal-iframe or .gs-modal-body
 *     <div class="gs-modal-iframe">
 *       <a href="#" role="button" class="close-modal id-no-nav close-x">╳</a>
 *       <iframe src="/widget/compatibility/doorbell" frameborder="0"
 * aria-label="widget" tabindex=0></iframe>
 *     </div>
 *     <div class="gs-modal-body">
 *       ...
 *     </div>
 *     <div class="gs-modal-footer"> // footer optional
 *       <a href="#" class="gs-modal-close waves-effect waves-green
 * btn-flat">Agree</a>
 *     </div>
 *   </div>
 *   <a href="#" role="button" class="overlay close-modal close-modal-end
 * id-no-nav"></a>
 * </div>
 * ```
 */

/**
 * Modal system
 */
window.ModalHandler = function() {
  const navbar = document.querySelector('[data-test-navbar]');
  const state = {origin: null, activeModal: null};
  let useSafariPolyfill;
  const TRACKABLE_ORIGINS = [
    'https://tryassistantmini.withgoogle.com',
    'https://interactivedemo.withgoogle.com',
  ];
  const getMannequinService = new Promise(resolve => {
    const interval = () => window.mannequinService ?
        resolve(window.mannequinService) :
        window.requestAnimationFrame(interval);
    window.requestAnimationFrame(interval);
  });


  /**
   * Safari Polyfill for setting origin link element
   * @param {!Event} event
   */
  const safariSetOriginHandler = event => {
    const relatedTarget = event.target;
    if (relatedTarget.hasAttribute('href')) {
      const url = relatedTarget.getAttribute('href');
      const uri = new URL(url);
      const modal = document.querySelector(`${uri.hash}.gs-modal`);
      if (modal) {
        setOrigin(relatedTarget, modal);
      }
    }
  };


  /**
    Note: using event.explicitOriginalTarget as a fix for FF. Safari still
    doesn't set relatedTarget on button or link clicks for FocusEvent.
    @param {!Element} relatedTarget
    @param {!Element} modal
  */
  const setOrigin = (relatedTarget, modal) => {
    const closeLinks = modal.querySelectorAll('.close-modal');

    if (relatedTarget) {
      state.origin = relatedTarget;

      if (!state.origin.id) {
        state.origin.id = `origin-${Date.now()}`;
      }

      closeLinks.forEach(link => link.href = `#${state.origin.id}`);
    }
  };


  /**
   * Handle focus out of modal and properly set focus back on origin links
   * @param {!Event} event
   */
  const modalFocusOutHandler = event => {
    const relatedTarget = event.relatedTarget || event.explicitOriginalTarget;
    if (state.activeModal && !state.activeModal.contains(relatedTarget)) {
      !relatedTarget && state.origin && state.origin.focus();
      triggerOutOfView(state.activeModal);
      state.activeModal = null;
    }
  };


  /**
   * Handle esc key while focus is on modal
   * @param {!Event} event
   */
  const escapeHandler = event => {
    const modal = event.target.closest('.gs-modal');
    if (modal && event.code === 'Escape') {
      setOrigin(state.origin, modal);
      const closeLink = modal.querySelector('.close-modal');
      closeLink.click();
      cleanupModal(modal);
    }
  };


  /**
   * Handle setting origin that triggered modal open
   * @param {!Event} event
   */
  const modalFocusHandler = event => {
    const modal = event.currentTarget;
    const close = modal.querySelector('.close-x');
    let setFocusOnCloseButton = state.activeModal !== modal;
    if (!useSafariPolyfill) {
      const relatedTarget = event.relatedTarget || event.explicitOriginalTarget;
      relatedTarget && setOrigin(relatedTarget, modal);
      setFocusOnCloseButton = ![close, modal].includes(relatedTarget);
    }

    getMannequinService.then(() => setupIframeModal(modal));
    document.body.classList.add('gs-modal-open');

    // Set focus on close if modal is not already open
    if (setFocusOnCloseButton) {
      close.focus();
      triggerInView(modal);
    }

    state.activeModal = modal;
  };


  /**
   * Focus on first close button on iframe focusout
   * NOTE: Used for modals with iframe
   * @param {!Event} event
   */
  const iframeFocusTrappingHandler = event => {
    const close =
        event.currentTarget.closest('.gs-modal').querySelector('.close-x');
    close.focus();
  };


  /**
   * Focus on first close button on modal focusout
   * NOTE: Used for modals without iframe
   * @param {!Event} event
   */
  const focusTrappingHandler = event => {
    const close = event.target.querySelector('.close-x');
    close.focus();
  };


  /**
   * Sets id-no-nav class on links that trigger modal
   * @param {!Element} modal
   */
  const setIdNoNav = modal => link => {
    const uri = new URL(link.href);
    if (uri.hash.substr(1) === modal.id) {
      link.classList.add('id-no-nav');
    }
  };


  /**
   * Sets up modal listeners and sets 'id-no-nav' on links with matching hash as
   * modal id
   * @param {!NodeList<?Element>} modal
   */
  const setupModal = modal => {
    const iframe = modal.querySelector('iframe');

    document.querySelectorAll(`[href*=${modal.id}]`).forEach(setIdNoNav(modal));

    if (iframe) {
      const close = modal.querySelector('.close-modal-end');
      close.addEventListener('focus', iframeFocusTrappingHandler);
      getMannequinService.then(mannequinService => {
        const url =
            mannequinService.maybeModifyUrl(iframe.getAttribute('data-src'));
        iframe.setAttribute('data-src', url);
      });
    } else {
      modal.addEventListener('transitionend', focusTrappingHandler);
    }

    modal.addEventListener('focus', modalFocusHandler);
    modal.addEventListener('focusout', modalFocusOutHandler);

    // Queue up checking modal visibility
    setTimeout(() => checkInitialVisibility(modal), 0);
  };


  /**
   * Ensure focus on modal if visible on load
   * @param {!Element} modal
   */
  const checkInitialVisibility = modal => {
    const display = window.getComputedStyle(modal).display;
    const close = modal.querySelector('.close-x');
    if (display === 'grid') {
      triggerInView(modal);
      close.focus();
      modalFocusHandler({currentTarget: modal});
    }
  };


  /**
   * Triggers analytics event when modal is opened
   * @param {!Element} modal
   */
  const triggerInView = modal => {
    modal.classList.add('in-view');

    const inView = document.createEvent('Event');
    inView.initEvent('in-view', true, true);

    modal.dispatchEvent(inView);

    // Prevent scrolling while modal is open
    document.body.style.overflowY = 'hidden';

    // Prevent navbar from overlapping modal
    navbar.style.zIndex = 'unset';
  };


  /**
   * Triggers analytics event when modal is closed
   * @param {!Element} modal
   */
  const triggerOutOfView = modal => {
    modal.classList.remove('in-view');

    const outOfView = document.createEvent('Event');
    outOfView.initEvent('out-of-view', true, true);

    modal.dispatchEvent(outOfView);

    // Reset style of body overflow and navbar z-index
    document.body.style.overflowY = null;
    navbar.style.zIndex = null;
  };


  // Depending on the origin of the postMessage, send all data, that contains
  // event key, from the event to dataLayer for analytics (b/184570644)
  const handlePostMessage = ({data, origin, source}) => {
    // Exit early if origin is not recognized
    if (!TRACKABLE_ORIGINS.includes(origin)) {
      return;
    }

    const callback = postMessageCallbacks[data.event ? 'event' : data.action];
    if (callback) {
      callback(data, origin, source);
    }
  };

  const getActiveModal = () => {
    const modals = [...document.querySelectorAll('.gs-modal')];
    return modals.find(modal => modal.offsetHeight > 0);
  };

  // Callbacks for postMessage from GROW
  const postMessageCallbacks = {
    // Push analytics event to datalayer
    'event': data => {
      const modal = getActiveModal();
      getMannequinService.then(mannequinService => {
        const moduleName = modal.dataset.sectionName;
        const moduleType = modal.dataset.moduleType;
        const event = data.eventData || data;

        event.moduleName = event.moduleName || moduleName;
        event.moduleType = event.moduleType || moduleType;
        event.eventAction = event.eventAction || moduleType;
        event.pageName = window.location.pathname || event.pageName;
        if (event.eventParams) {
          event.eventParams.pageName =
              window.location.pathname || event.pageName;
        }
        mannequinService.logEvent(event);
      });
    },

    // Fetch bundle price and send back to origin window
    'get-bundle-price': ({id, productQuantityMap}, origin, source) => {
      getMannequinService.then(mannequinService => {
        mannequinService.getBundlePrice(productQuantityMap)
            .then(({priceInformation}) => {
              priceInformation.identifier = id;
              source.postMessage({priceInformation}, origin);
            });
      });
    },

    // Close all modals
    'close-modal': () => {
      const modal = getActiveModal();
      setOrigin(state.origin, modal);
      modal.querySelector('.close-modal').click();
      cleanupModal(modal);
    },

    // Fetch CTA status/label by page docid
    'get-product-cta-state': ({productQuantityMap}, origin, source) => {
      const docids = productQuantityMap.map(({docid}) => docid);
      getMannequinService.then(mannequinService => {
        mannequinService.fetchProductCtaData(docids).then(ctaMap => {
          let productCtaState = {};
          ctaMap.forEach((cta, docid) => productCtaState[docid] = cta.label);
          source.postMessage({productCtaState}, origin);
        });
      });
    }
  };

  const setupIframeModal = modal => {
    const iframe = modal.querySelector('iframe');

    if (iframe) {
      const source = iframe.getAttribute('data-src');
      const {origin} = new URL(source);
      // Set source if it hasn't been already set
      if (!iframe.hasAttribute('src')) {
        iframe.setAttribute('src', source);
      }

      // Adding class if source is a product experience modal
      if (TRACKABLE_ORIGINS.includes(origin)) {
        modal.classList.add('gs-product-experience-modal');
      }
    }
  };

  const cleanupModal = modal => {
    const iframe = modal.querySelector('iframe');

    if (iframe) {
      iframe.removeAttribute('src');
      document.querySelectorAll('[role=navigation]')
          .forEach(nav => nav.style.removeProperty('z-index'));
    }

    document.body.classList.remove('gs-modal-open');
  };


  this.init = () => {
    const modals = document.querySelectorAll('.gs-modal');
    getMannequinService.then(({isSafari}) => {
      useSafariPolyfill = isSafari;
      if (isSafari) {
        document.addEventListener('click', safariSetOriginHandler);
      }
    });
    document.addEventListener('keyup', escapeHandler);
    window.addEventListener('message', handlePostMessage);
    if (modals) {
      modals.forEach(setupModal);
    }
  };


  this.destroy = () => {
    const modals = document.querySelectorAll('.gs-modal');
    // Not removing event listeners from modal since
    // we are removing them from the DOM
    if (modals) {
      modals.forEach(modal => {
        cleanupModal(modal);
        modal.remove();
      });
    }
    document.removeEventListener('click', safariSetOriginHandler);
    document.removeEventListener('keyup', escapeHandler);
    window.removeEventListener('message', handlePostMessage);
  };


  this.init();
};
"use strict";

/**
 * @fileoverview This file handles mapping used for the wombat_router.js file.
 * Each query selector corresponds to a ClassName that is bound to the window.
 */

window.wombatRoutes = {
  '[template-modalizer]': ['TemplateModalizer'],
  '[wombat-template] [data-telephone]': ['WombatPhoneLinks'],
  '[wombat-template] [format-anchors]': ['WombatFormatAnchors'],
  '[wombat-template] [lazy-load], [wombat-template][lazy-load]':
      ['WombatLazyLoad'],
  '[wombat-template] .async-cta': ['WombatAsyncCtaHandler'],
  '[wombat-template].accordion-module': ['WombatAccordionModule'],
  '[wombat-template][element-watcher], .gs-modal[element-watcher]':
      ['WombatElementWatcherDefaults'],
  '[wombat-template] [data-gsi-modal-trigger]': ['WombatModalRouter'],
  '[wombat-template][data-module-type], .gs-modal[data-module-type]':
      ['WombatAnalytics'],
  '[wombat-template].wombat_hero_with_background_video':
      ['WombatHeroWithBackgroundVideo'],
  '[wombat-template].wombat_hero_with_background_image':
      ['WombatHeroWithBackgroundImage'],
  '[wombat-template].wombat_gallery_color_picker': ['WombatGalleryColorPicker'],
  '[wombat-template].wombat_tab_gallery': ['WombatTabGallery'],
  '[wombat-template].wombat_timeline_gallery': ['WombatTimelineGallery'],
  '[wombat-template].wombat_tabbed_gallery_right':
      ['WombatTabbedGalleryLeftRight'],
  '[wombat-template].wombat_50_50_img_right_gallery':
      ['Wombat5050ImgRightGallery'],
  '[wombat-template].wombat_50_50_img_left_assistant_speech_bubble_animated':
      ['Wombat5050ImgLeftAssistantSpeechBubbleAnimated'],
  '[wombat-template].wombat_thermostat_e_hero_clouds_animated':
      ['WombatThermostatEHeroCloudsAnimated'],
  '[wombat-template].wombat_tabbed_gallery_left':
      ['WombatTabbedGalleryLeftRight'],
  '[wombat-template].wombat_50_50_flexible_product_feature video':
      ['WombatVideoPlayer'],
  '[wombat-template].wombat_multi_column_feature_list':
      ['WombatMultiColumnFeatureList'],
  '[wombat-template] .wombat_side_scroll_scope': ['WombatSideScroller'],
  '[wombat-template].wombat_learning_thermostat_timeline_gallery':
      ['WombatLearningThermostatTimelineGallery'],
  '[wombat-template].wombat_hero_with_image_or_video_left_or_right_copy video':
      ['WombatVideoPlayer'],
  '[wombat-template].wombat_video_player video': ['WombatVideoPlayer'],
  '[wombat-template].wombat_pdp_bar_promo': ['WombatPdpBarPromo'],
  '[wombat-template].wombat_comparison_cards_long_cameras':
      ['WombatComparisonCardsLong'],
  '[wombat-template].wombat_comparison_header': ['WombatComparisonHeader'],
  '[wombat-template].wombat_zip_checker': ['WombatZipChecker'],
  '[wombat-template].wombat_comparison_cards_long_thermostats':
      ['WombatComparisonCardsLong'],
  '[wombat-template].wombat_two_cards_up': ['WombatTwoCardsUp'],
  '[wombat-template].wombat_geo_promo_banner': ['WombatGeoPromoBanner'],
  '[wombat-template].wombat_mpc': ['WombatMpc'],
  '[wombat-template].wombat_50_50_g1': ['Wombat5050G1'],
  '[wombat-template].wombat_promo_touts': ['WombatPromoTouts'],
  '[wombat-template].wombat_promo_hero_pdp': ['WombatPromoTouts'],
  '[wombat-template].wombat_product_image_gallery':
      ['WombatProductImageGallery'],
  '[wombat-template].wombat_accessories_wall': ['WombatAccessoriesWall'],
  '[wombat-template].wombat_special_offers': ['WombatSpecialOffers'],
  '[wombat-template].template_product_wall': ['TemplateProductWall'],
  '[wombat-template].custom_video_page': ['CustomVideoPages'],
  '[wombat-template].template_crm': ['TemplateCRM'],
  '[wombat-template].template_rebates_banner': ['TemplateRebatesBanner'],
  '[wombat-template].template_rebates_zip_checker':
      ['TemplateRebatesZipChecker'],
  '[wombat-template].wombat_tech_specs_single_list':
      ['WombatTechSpecsSingleList'],
  '[wombat-template].template_ratings_and_reviews_display':
      ['TemplateRatingsAndReviewsDisplay'],
};
'use strict';

/**
 * @fileoverview This file handles execution and destruction of Classes bound to
 * the window based on query selectors defined in wombat_routes.js
 */

const initializedClasses = [];
let modalHandler;
let isRouteWatcherInitialized = false;

/**
 * Handles safe execution of functions
 * @template R
 * @param {function(*):R} cb Callback function to be executed
 * @param {function(!Exception)=} msgHandler Error message handler to be
 *     executed on error
 * @return {?R} Returns the executed result of cb
 */
const executeSafely = (cb, msgHandler = (e) => e) => {
  try {
    return cb();
  } catch (e) {
    console.error(msgHandler(e));
    return undefined;
  }
};

/**
 * Handles initialization of Classes that are bound to query selectors.
 * @function initializeRoutes
 */
function initializeRoutes() {
  const errorMsgHandler = (moduleName) => (e) =>
      `There was an error initializing this module: ${moduleName}: ${e}`;

  modalHandler =
      executeSafely(() => new ModalHandler(), errorMsgHandler('ModalHandler'));

  // TODO(jup) Make sure to keep track of this so that this doesn't get misse.
  // executeSafely(() => SEOHandler(), errorMsgHandler('SEOHandler'));


  for (const routeQuery of Object.keys(wombatRoutes)) {
    const classNames = wombatRoutes[routeQuery];
    const elements = document.querySelectorAll(routeQuery);

    for (const element of elements) {
      for (const className of classNames) {
        // TODO(marclipovsky) Improve error handling
        // strip console logging with template infrastructure plans
        const initialize = () => {
          const instanceOfClass = new window[className](element);
          initializedClasses.push(instanceOfClass);
        };
        const errorHandler = (e) =>
            `There was an error initializing ${className} for element ${
                element.outerHTML.replace(element.innerHTML, '')}: ${e}`;

        executeSafely(initialize, errorHandler);
      }
    }
  }

  /**
   * Activate optimize after initialization to make sure optimize gets
   * fired after DOM elements are initialized.
   */
  dataLayer.push({'event': 'optimize.activate'});
}

/**
 * Takes the currently running classes on the page, and run the teardown
 * "destroy" method on each of them.
 * @function destroyRunningClasses
 */
function destroyRunningClasses() {
  executeSafely(
      () => modalHandler.destroy(),
      (e) => `There was an error destroying modalHandler': ${e}`);
  while (initializedClasses.length) {
    try {
      const instanceOfClass = initializedClasses[0];
      if (instanceOfClass.destroy) {
        instanceOfClass.destroy();
      }
    } catch (e) {
      console.error(e);
    } finally {
      initializedClasses.splice(0, 1);
    }
  }
}

/**
 * @function this function watches for the Smith DOM events to initialize or
 * destroy classes.
 */
function initializeRouteWatcher() {
  isRouteWatcherInitialized = true;

  document.addEventListener(
      'mannequinImpendingNavigation', destroyRunningClasses);

  document.addEventListener('DOMContentLoaded', initializeRoutes);
}

if (!isRouteWatcherInitialized) {
  initializeRouteWatcher();
}
